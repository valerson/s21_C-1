#ifndef BACKEND_TETRIS_H
#define BACKEND_TETRIS_H

#include <stdbool.h>
#include <sys/time.h>  // для определения микросекунд
#include <time.h>      // для рандома

#define FIGURE_H 4
#define FIGURE_W 4

#define LEFT_KEY 75
#define RIGHT_KEY 77
#define DOWN_KEY 80

#define SPEED_START 10;

#define X_START 3  // сдвиг ыигуры на центр игрового поля

// Структура содержащая необходимую ВСЮ информацию для передачи в
typedef struct {
  int **field;     // Матрица для игрового поля
  int **next;      // Матрица для следующей фигуры
  int score;       // Количество очков
  int high_score;  // Рекорд хранящийся в памяти
  int level;       // Уровень
  int speed;       // Скорость уровня
  int pause;       // 0 - играем, 1 - пауза, 2 - конец игры
} GameInfo_t;

typedef enum {
  Start,      // Начало             0
  Pause,      // Пауза              1
  Terminate,  // Завершение игры    2
  Left,       // Влево              3
  Right,      // Вправо             4
  Up,         // Вверх              5
  Down,       // Вниз               6
  Action      // Вращение фигуры    7
} UserAction_t;

// структура - позиция левого нижнего элемента массива фигуры
typedef struct {
  int **figure;       // Матрица для текущей фигуры
  int **next_figure;  // Матрица для следующей фигуры
  int x;              // текущая позиция x фигуры !!!!
  int y;  // нижний пиксель не ноль у фигуры (не меняется)
  int x_levo;  // крайний левый пиксель фигуры (не меняется)
  int y_up;
  int y_down;
  int x_left;
  int x_right;
  int figure_number;
  int next_figure_number;
  int rotate;
  int next_figure_rotate;
} FigureInfo_t;

void userInput(UserAction_t action, bool hold);

// 7 - количество фигур 4 - номер переворота 4 - строки 4 - столбца
static int Figures[7][4][4][4] = {
    {{{8, 8, 8, 8}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}},
     {{0, 8, 0, 0}, {0, 8, 0, 0}, {0, 8, 0, 0}, {0, 8, 0, 0}},
     {{8, 8, 8, 8}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}},
     {{0, 8, 0, 0}, {0, 8, 0, 0}, {0, 8, 0, 0}, {0, 8, 0, 0}}},

    {{{0, 13, 0, 0}, {0, 13, 13, 13}, {0, 0, 0, 0}, {0, 0, 0, 0}},
     {{0, 13, 13, 0}, {0, 13, 0, 0}, {0, 13, 0, 0}, {0, 0, 0, 0}},
     {{0, 13, 13, 13}, {0, 0, 0, 13}, {0, 0, 0, 0}, {0, 0, 0, 0}},
     {{0, 0, 13, 0}, {0, 0, 13, 0}, {0, 13, 13, 0}, {0, 0, 0, 0}}},

    {{{0, 0, 0, 9}, {0, 9, 9, 9}, {0, 0, 0, 0}, {0, 0, 0, 0}},
     {{0, 0, 9, 0}, {0, 0, 9, 0}, {0, 0, 9, 9}, {0, 0, 0, 0}},
     {{0, 9, 9, 9}, {0, 9, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}},
     {{0, 9, 9, 0}, {0, 0, 9, 0}, {0, 0, 9, 0}, {0, 0, 0, 0}}},

    {{{0, 7, 7, 0}, {0, 7, 7, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}},
     {{0, 7, 7, 0}, {0, 7, 7, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}},
     {{0, 7, 7, 0}, {0, 7, 7, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}},
     {{0, 7, 7, 0}, {0, 7, 7, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}},

    {{{0, 10, 10, 0}, {10, 10, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}},
     {{0, 10, 0, 0}, {0, 10, 10, 0}, {0, 0, 10, 0}, {0, 0, 0, 0}},
     {{0, 10, 10, 0}, {10, 10, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}},
     {{0, 10, 0, 0}, {0, 10, 10, 0}, {0, 0, 10, 0}, {0, 0, 0, 0}}},

    {{{0, 14, 14, 0}, {0, 0, 14, 14}, {0, 0, 0, 0}, {0, 0, 0, 0}},
     {{0, 0, 14, 0}, {0, 14, 14, 0}, {0, 14, 0, 0}, {0, 0, 0, 0}},
     {{0, 14, 14, 0}, {0, 0, 14, 14}, {0, 0, 0, 0}, {0, 0, 0, 0}},
     {{0, 0, 14, 0}, {0, 14, 14, 0}, {0, 14, 0, 0}, {0, 0, 0, 0}}},

    {{{0, 0, 4, 0}, {0, 4, 4, 4}, {0, 0, 0, 0}, {0, 0, 0, 0}},
     {{0, 0, 4, 0}, {0, 0, 4, 4}, {0, 0, 4, 0}, {0, 0, 0, 0}},
     {{0, 4, 4, 4}, {0, 0, 4, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}},
     {{0, 0, 4, 0}, {0, 4, 4, 0}, {0, 0, 4, 0}, {0, 0, 0, 0}}}};

// создание матриц структуры гейминфо
void init_GameInfo();
// полная инициализация структуры фигуринфо включая создание нулевых матриц
void init_FigureInfo();
// освобождение памяти матриц структуры гейминфо
void free_GameInfo();
// освобождение памяти матриц в структуре Фигуринфо
void free_FigureInfo();

// генерация текущей фигуры и следующей рандом
void start_figure();

// генерация фигуры из файла
int create_figure(int ***figure);
// получение параметров фигуры
void get_params_figure(int **figure);
void update_figure();

// проерка на движение налево
int is_cant_move_left();
// дейсвтие - движение влево
void move_left();
// дейсвтие - движение вправо
void move_right();
// проерка на движение направо
int is_cant_move_right();
// проверка на возможность движения вниз
int is_cant_move_down();
// сбор функций для движения фигуры вниз
void func_move_down(GameInfo_t *GameInf, FigureInfo_t Figure);

void move_down();
// проерка на поворот фигуры
int is_cant_move_turn();
// действие - поворот фигуры
void move_turn();

void userInput(UserAction_t action, bool hold);
GameInfo_t updateCurrentState();
// вырезаем фигуру из поля. на месте фигуры 0
void cut_figure_from_field();
// проверка на возможность размещения стартовой фигуры
int check_new_figure_at_field();
// проверка линии на заполенность и ее "сжигание"
void check_full_line();

void save_new_record();
FigureInfo_t ExportFigure();

void parsing_input(int input, bool hold);

// для мэйн
// подсчет микросекунд (чтобы двигать фигуры внутри тайминга действия)
unsigned long long current_microseconds();

#endif